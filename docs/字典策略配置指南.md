# 字典策略配置指南

## 概述

拼音转换项目支持三种字典加载策略，可通过环境变量进行配置，以适应不同的使用场景和性能要求。

## 策略类型

### 1. both (默认策略)
同时加载带声调和无声调字典。

**特点:**
- ✅ 兼容性最好，支持所有功能
- ✅ 响应速度最快
- ❌ 内存占用最高

**适用场景:**
- 高并发Web应用
- 对响应时间要求严格的系统
- 内存充足的服务器环境

### 2. with_tone
仅加载带声调字典，需要无声调时实时去除声调。

**特点:**
- ✅ 内存占用中等
- ✅ 支持所有功能
- ⚠️ 无声调转换略有性能损耗

**适用场景:**
- 内存受限但需要完整功能的环境
- 带声调和无声调混合使用的场景
- 中小型Web应用

### 3. no_tone
仅加载无声调字典。

**特点:**
- ✅ 内存占用最低
- ✅ 无声调转换最快
- ❌ 无法提供带声调拼音

**适用场景:**
- 纯无声调应用（如URL Slug生成）
- 内存严重受限的环境
- 仅需要基础拼音转换的场景

## 配置方法

### 环境变量配置

1. 复制配置示例文件:
```bash
cp .env.example .env
```

2. 编辑 `.env` 文件:
```bash
# 字典加载策略
PINYIN_DICT_STRATEGY=with_tone

# 缓存大小（可选）
PINYIN_DICT_CACHE_SIZE=1000

# 懒加载（可选）
PINYIN_LAZY_LOADING=true
```

### 代码中配置

```php
use tekintian\pinyin\PinyinConverter;
use tekintian\pinyin\Utils\PinyinConstants;

// 方法1: 通过环境变量
putenv(PinyinConstants::ENV_DICT_STRATEGY . '=' . PinyinConstants::DICT_STRATEGY_WITH_TONE);
$converter = new PinyinConverter();

// 方法2: 通过构造函数参数
$converter = new PinyinConverter([
    'dict_loading' => [
        'strategy' => PinyinConstants::DICT_STRATEGY_WITH_TONE
    ]
]);
```

## 性能对比

| 策略 | 初始化时间 | 运行内存 | 转换速度 | 功能完整性 |
|------|------------|----------|----------|------------|
| both | 慢 | 高 | 快 | 完整 |
| with_tone | 中 | 中 | 中等 | 完整 |
| no_tone | 快 | 低 | 快(无声调) | 部分 |

## 使用建议

### 高性能场景
```bash
PINYIN_DICT_STRATEGY=both
PINYIN_DICT_CACHE_SIZE=3000
PINYIN_LAZY_LOADING=false
```

### 内存优化场景
```bash
PINYIN_DICT_STRATEGY=with_tone
PINYIN_DICT_CACHE_SIZE=500
PINYIN_LAZY_LOADING=true
```

### 纯无声调场景
```bash
PINYIN_DICT_STRATEGY=no_tone
PINYIN_DICT_CACHE_SIZE=300
PINYIN_LAZY_LOADING=true
```

## 性能测试

使用内置的性能测试工具:

```bash
php tools/performance_comparison.php
```

该工具会测试三种策略的性能差异，并给出针对性建议。

## 迁移指南

### 从现有系统迁移

1. **评估当前需求**
   - 是否需要带声调拼音？
   - 内存限制如何？
   - 并发量多大？

2. **选择合适策略**
   - 根据评估结果选择最适合的策略
   - 使用性能测试工具验证

3. **逐步迁移**
   - 先在测试环境验证
   - 监控性能指标
   - 确认功能完整性后再上线

### 兼容性说明

- **API兼容**: 所有策略的API调用方式完全一致
- **功能差异**: 仅 `no_tone` 策略无法提供带声调拼音
- **配置迁移**: 现有配置文件无需修改，只需添加环境变量

## 故障排除

### 常见问题

1. **内存不足错误**
   - 改用 `with_tone` 或 `no_tone` 策略
   - 减小缓存大小
   - 启用懒加载

2. **带声调功能异常**
   - 检查是否使用了 `no_tone` 策略
   - 确认环境变量设置正确

3. **性能下降**
   - 检查是否启用了合适的缓存大小
   - 考虑关闭懒加载（如果内存充足）

### 调试方法

```php
// 获取当前策略
$strategy = $converter->config['dict_loading']['strategy'];
echo "当前字典策略: " . $strategy . "\n";

// 获取性能报告
$report = $converter->getPerformanceReport();
print_r($report);
```

## 最佳实践

1. **生产环境**
   - 使用环境变量配置
   - 启用适当的缓存
   - 监控内存使用情况

2. **开发环境**
   - 使用 `both` 策略确保功能完整
   - 便于调试和测试

3. **测试环境**
   - 模拟生产环境配置
   - 进行性能基准测试

4. **CI/CD**
   - 在测试流程中加入性能测试
   - 验证不同策略下的功能正确性




# 新环境变量方案与现有字典加载配置之间的关系：

## 现有配置 vs 新环境变量方案的关系

### 1. **现有配置结构**
```php
'dict_loading' => [
    'strategy' => 'both', // 'both'|'with_tone'|'no_tone' - 字典加载策略
    'lazy_loading' => true, // 是否启用懒加载（默认启用）
    'preload_priority' => ['custom', 'common'], // 预加载优先级
    'lazy_dicts' => ['rare', 'unihan'] // 懒加载的字典类型
]
```

### 2. **新环境变量方案**
新增了三个环境变量：
- `PINYIN_DICT_STRATEGY`: 控制字典加载策略
- `PINYIN_DICT_CACHE_SIZE`: 控制缓存大小  
- `PINYIN_LAZY_LOADING`: 控制懒加载开关

### 3. **关系和优先级**

**配置优先级（从高到低）：**
1. 环境变量（最高优先级）
2. 构造函数传入的 `$options` 参数
3. 默认配置（最低优先级）

**具体实现逻辑：**
```php
// 从环境变量加载配置
$envConfig = $this->loadEnvironmentConfig();
// 环境变量配置会覆盖默认配置
$this->config = array_replace_recursive($this->config, $envConfig, $options);
```

### 4. **映射关系**

| 环境变量 | 对应配置项 | 默认值 | 说明 |
|---------|-----------|--------|------|
| `PINYIN_DICT_STRATEGY` | `dict_loading.strategy` | `both` | 字典加载策略 |
| `PINYIN_DICT_CACHE_SIZE` | `high_freq_cache.size` | `1000` | 缓存大小 |
| `PINYIN_LAZY_LOADING` | `dict_loading.lazy_loading` | `true` | 懒加载开关 |

### 5. **兼容性保证**

- **向后兼容**：如果不设置环境变量，系统使用原有的默认配置
- **灵活配置**：环境变量可以覆盖默认配置，但仍可通过构造函数参数进一步覆盖
- **策略一致性**：新方案中的策略值与现有配置完全一致

### 6. **实际使用场景**

**开发环境：**
```bash
# 开发时使用最小内存配置
export PINYIN_DICT_STRATEGY=no_tone
export PINYIN_DICT_CACHE_SIZE=500
```

**生产环境：**
```bash
# 生产环境使用完整配置
export PINYIN_DICT_STRATEGY=both
export PINYIN_DICT_CACHE_SIZE=2000
```

**测试环境：**
```bash
# 测试环境禁用懒加载，确保测试稳定性
export PINYIN_LAZY_LOADING=false
```

### 7. **核心优势**

1. **环境隔离**：不同环境可以使用不同的字典策略，无需修改代码
2. **部署灵活性**：通过环境变量快速调整性能参数
3. **配置统一**：将分散的配置项集中到环境变量中管理
4. **零侵入**：不影响现有的代码逻辑和配置方式

这个方案本质上是在现有配置系统基础上增加了一层环境变量覆盖，提供了更灵活的部署和运维能力，同时保持了完全的向后兼容性。